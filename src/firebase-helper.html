<link rel="import" href="../bower_components/polymer/polymer.html">

<script>
Polymer.FirebaseHelper = {
  _firebaseUpdateUserInfo: function(user) {
    this.set('_teams', []);

    if (!user)
      return;

    if (this.offline) {
      this.$.loading.hidden = true;
    }

    firebase.database().ref('/users/' + user.uid).once('value', function(snapshot) {
      var userInfo = snapshot.val();

      this.$.newPost.hidden = false;
      this.$.newPost._emojify();
      this.$.loading.hidden = true;

      // If online, try to update the can/can't edit public teams
      this._firebaseUpdatePublicTeams();

      if (userInfo) {
        console.log('Existing user:', this.user);

        // Get this user's private teams, if any.
        if (!this.offline)
          this._firebaseGetUserTeams(snapshot.val().teams || []);

      } else {
        console.log('New user!');

        firebase.database().ref('/users/').child(user.uid)
            .set({
              id: user.uid,
              name: user.displayName,
              email: user.email,
              photo: user.photoURL,
              createdAt: {'.sv': 'timestamp'}
            });
      }
    }.bind(this));
  },

  _firebaseUpdatePublicTeams: function() {
    var self = this;
    for (var i = 0; i < this.publicTeams.length; i++) {
      firebase.database().ref('/teams/' + this.publicTeams[i].$key).once('value', function(snapshot) {
        var team = snapshot.val();
        if (!snapshot.val())
          return;

        // HACK: Since we want to reuse the same UI code for the pre-online details,
        // reuse the $key property.
        team.$key = snapshot.key;

        // `this` is the index in the array, i know that's weird but halp?
        self.set(['publicTeams', Number(this)], team);
      }.bind(i));  // lol omg
    }
  },

  _firebaseGetUserTeams: function(teamIds) {
    var self = this;

    for (var i = 0; i < teamIds.length; i++) {
      firebase.database().ref('/teams/' + teamIds[i]).once('value', function(snapshot) {
        this._processOneTeam(snapshot.key);
      }.bind(this));
    }
  },

  _processOneTeam: function(teamId) {
    firebase.database().ref('/teams/' + teamId).once('value', function(snapshot) {
      // This team may not exist.
      if (snapshot.val()) {
        // Push instead of set so that we can do this incrementally I guess.
        var obj = snapshot.val();
        obj.key = snapshot.key;
        this.push('_teams', obj);
      }
    }.bind(this));
  },

  _firebaseAddMessage: function(team, message, location) {
    // Get the team ref from the names -> keys mapping
    firebase.database().ref('/teamNames/' + team).once('value', function(snapshot) {
      var teamRef = snapshot.val().id;
      var now = new Date().getTime();

      firebase.database().ref('/posts/').child(teamRef)
        .push({
          name: this.user.displayName,
          message: message,
          email: this.user.email,
          uid: this.user.uid,
          image: this.user.photoURL,
          likes: 0,
          location: location,
          createdAt: now,
          index: -now  /* because reverse sorting firebase data is hard */
        });
    }.bind(this));
  },

  _firebaseLikeMessage: function(post, team) {
    firebase.database().ref('/posts/' + team).child(post).once('value', function(snapshot) {
      var likes = snapshot.val().likes || 0;
      snapshot.ref.child('likes').set(likes + 1);
    });
  },

  _firebaseUnlikeMessage: function(post, team) {
    firebase.database().ref('/posts/' + team).child(post).once('value', function(snapshot) {
      var likes = snapshot.val().likes || 0;
      if (likes !== 0) {
        snapshot.ref.child('likes').set(likes - 1);
      }
    });
  },

  _firebaseDeleteMessage: function(post, team) {
    firebase.database().ref('/posts/' + team).child(post).remove();
  },

  _firebaseAddTeam: function(team, users, isPublic) {
    var self = this;

    // Check if the team already exists.
    firebase.database().ref('/teamNames/' + team).once('value', function(snapshot) {
      if (snapshot.val()) {
        self.$.newTeam.showError('Oops! This name is already taken.');
      } else {
        self.$.newTeam.hide();

        // Add this user as an user if they didn't add themselves already
        if (users.indexOf(self.user.email) === -1) {
          users.splice(0, 0, self.user.email);
        }

        // Create the team.
        var teamObj = {
          name: team,
          owner: self.user.uid,
          ownerEmail: self.user.email,
          users: users.length == 0 ? null : users,
          public: isPublic,
          createdAt: {'.sv': 'timestamp'}
        }

        var teamRef = firebase.database().ref('/teams/').push(teamObj);
        teamObj.key = teamRef.key;

        // If it's public, also add it to the public teams.
        if (isPublic) {
          firebase.database().ref('/publicTeams/').child(teamRef.key).set({name:team});
        }

        // Add it to the UI now because the next steps could be slow.
        self.push('_teams', teamObj);

        // Also add it in the name -> key mapping.
        firebase.database().ref('/teamNames/').child(team).set({id:teamRef.key});

        if (isPublic)
          return;

        // Add this team to this user.
        firebase.database().ref('/users/' + self.user.uid).once('value', function(snapshot) {
          var userTeams = snapshot.val().teams || [];
          userTeams.push(teamRef.key);
          snapshot.ref.update({teams: userTeams});
        });

        // For each of the users in the list, add this team to them.
        // The problem is that the user only entered emails, so we have to go
        // through the whole database and match emails(since they're not keys)
        // TODO: figure out if there's a better way.
        firebase.database().ref('/users/').once('value', function(snapshot) {
          var allUsers = snapshot.val();

          for (var user in allUsers) {
            // This user is in the new team! (but may be us, so skip us)
            if (allUsers[user].email !== self.user.email &&
              users.indexOf(allUsers[user].email) != -1 ) {
              var userTeams = allUsers[user].teams || [];
              userTeams.push(teamRef.key);
              firebase.database().ref('/users/' + user).update({teams: userTeams});
            }
          }
        });
      }
    });
  },

  _firebaseDeleteTeam: function(ref, teamName) {
    var displayedPage = this.$.pages.querySelector('view-posts.iron-selected');

    // Delete this from the names -> keys table.
    firebase.database().ref('/teamNames/').child(teamName).remove();

    // Delete this from the main teams table.
    firebase.database().ref('/teams/').child(ref).remove();

    // Delete this from the public teams table.
    firebase.database().ref('/publicTeams/').child(ref).remove();

    this.$.newTeam.hide();

    // Switch to the global team since we're now displaying junk data.
    this.set('routeData.page', 'global');

    // Delete the old posts list.
    if (displayedPage.ref === ref) {
      Polymer.dom(this.$.pages).removeChild(displayedPage);
    }

    // TODO: could optionally delete this from the users too.

    // Delete this from the UI.
    for (var i = 0; i < this.teams.length; i++) {
      if (this.teams[i].name === teamName) {
        this.splice('_teams', i, 1);
        return;
      }
    }
  },

  _firebaseRenameTeam: function(ref, oldName, newName) {
    var self = this;

    // Check if the new team already exists.
    firebase.database().ref('/teamNames/' + newName).once('value', function(snapshot) {
      if (snapshot.val()) {
        self.$.newTeam.showError('Oops! This name is already taken.');
      } else {
        // Update the name in the main teams table
        firebase.database().ref('/teams/').child(ref).update({name: newName})
            .then(function(success) {
              // Update the name in the names -> keys table.
              firebase.database().ref('/teamNames/').child(oldName).remove();
              firebase.database().ref('/teamNames/').child(newName).set({id:ref});

              self.$.newTeam.hide();

              // Update the name in the UI
              for (var i = 0; i < self.teams.length; i++) {
                if (self.teams[i].name === oldName) {
                  self.set(['_teams', i, 'name'], newName);
                  return;
                }
              }
            }, function(error) {
              console.log(error)
              self.$.newTeam.showError('Permission denied. Are you sure you\'re allowed to do this?');
            });
      }
    });
  },

  _firebaseAddUsers: function(ref, newUsers) {
    this.$.newTeam.hide();

    // Add these users in the teams database
    firebase.database().ref('/teams/' + ref).once('value', function(snapshot) {
      var currentUsers = snapshot.val().users;
      currentUsers = currentUsers.concat(newUsers);
      snapshot.ref.update({users: currentUsers});
    });

    // For each of the users in the list, add this team to them.
    firebase.database().ref('/users/').once('value', function(snapshot) {
      var users = snapshot.val();

      for (var user in users) {
        if (newUsers.indexOf(users[user].email) != -1 ) {
          var currentUserTeams = users[user].teams || [];
          currentUserTeams.push(ref);
          firebase.database().ref('/users/' + user).update({teams: currentUserTeams});
        }
      }
    });
  },

  _firebaseDeleteUsers: function(ref, delUsers) {
    this.$.newTeam.hide();

    // Remove these users in the teams database
    firebase.database().ref('/teams/' + ref).once('value', function(snapshot) {
      var currentUsers = snapshot.val().users;

      for (var user in delUsers) {
        var index = currentUsers.indexOf(delUsers[user]);
        if (index != -1 ) {
          currentUsers.splice(index, 1);
        }
      }
      snapshot.ref.update({users: currentUsers});
    });


    // For each of the users in the list, remove this team from them.
    firebase.database().ref('/users/').once('value', function(snapshot) {
      var users = snapshot.val();

      for (var user in users) {
        if (delUsers.indexOf(users[user].email) != -1 ) {
          var currentUserTeams = users[user].teams || [];
          var teamIndex = currentUserTeams.indexOf(ref);
          currentUserTeams.splice(teamIndex, 1);
          firebase.database().ref('/users/' + user).update({teams: currentUserTeams});
        }
      }
    });
  }
};
</script>
